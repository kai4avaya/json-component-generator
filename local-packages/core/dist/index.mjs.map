{"version":3,"sources":["../src/types.ts","../src/visibility.ts","../src/actions.ts","../src/validation.ts","../src/catalog.ts"],"sourcesContent":["import { z } from \"zod\";\r\n\r\n/**\r\n * Dynamic value - can be a literal or a path reference to data model\r\n */\r\nexport type DynamicValue<T = unknown> = T | { path: string };\r\n\r\n/**\r\n * Dynamic string value\r\n */\r\nexport type DynamicString = DynamicValue<string>;\r\n\r\n/**\r\n * Dynamic number value\r\n */\r\nexport type DynamicNumber = DynamicValue<number>;\r\n\r\n/**\r\n * Dynamic boolean value\r\n */\r\nexport type DynamicBoolean = DynamicValue<boolean>;\r\n\r\n/**\r\n * Zod schema for dynamic values\r\n */\r\nexport const DynamicValueSchema = z.union([\r\n  z.string(),\r\n  z.number(),\r\n  z.boolean(),\r\n  z.null(),\r\n  z.object({ path: z.string() }),\r\n]);\r\n\r\nexport const DynamicStringSchema = z.union([\r\n  z.string(),\r\n  z.object({ path: z.string() }),\r\n]);\r\n\r\nexport const DynamicNumberSchema = z.union([\r\n  z.number(),\r\n  z.object({ path: z.string() }),\r\n]);\r\n\r\nexport const DynamicBooleanSchema = z.union([\r\n  z.boolean(),\r\n  z.object({ path: z.string() }),\r\n]);\r\n\r\n/**\r\n * Base UI element structure for v2\r\n */\r\nexport interface UIElement<\r\n  T extends string = string,\r\n  P = Record<string, unknown>,\r\n> {\r\n  /** Unique key for reconciliation */\r\n  key: string;\r\n  /** Component type from the catalog */\r\n  type: T;\r\n  /** Component props */\r\n  props: P;\r\n  /** Child element keys (flat structure) */\r\n  children?: string[];\r\n  /** Parent element key (null for root) */\r\n  parentKey?: string | null;\r\n  /** Visibility condition */\r\n  visible?: VisibilityCondition;\r\n}\r\n\r\n/**\r\n * Visibility condition types\r\n */\r\nexport type VisibilityCondition =\r\n  | boolean\r\n  | { path: string }\r\n  | { auth: \"signedIn\" | \"signedOut\" }\r\n  | LogicExpression;\r\n\r\n/**\r\n * Logic expression for complex conditions\r\n */\r\nexport type LogicExpression =\r\n  | { and: LogicExpression[] }\r\n  | { or: LogicExpression[] }\r\n  | { not: LogicExpression }\r\n  | { path: string }\r\n  | { eq: [DynamicValue, DynamicValue] }\r\n  | { neq: [DynamicValue, DynamicValue] }\r\n  | { gt: [DynamicValue<number>, DynamicValue<number>] }\r\n  | { gte: [DynamicValue<number>, DynamicValue<number>] }\r\n  | { lt: [DynamicValue<number>, DynamicValue<number>] }\r\n  | { lte: [DynamicValue<number>, DynamicValue<number>] };\r\n\r\n/**\r\n * Flat UI tree structure (optimized for LLM generation)\r\n */\r\nexport interface UITree {\r\n  /** Root element key */\r\n  root: string;\r\n  /** Flat map of elements by key */\r\n  elements: Record<string, UIElement>;\r\n}\r\n\r\n/**\r\n * Auth state for visibility evaluation\r\n */\r\nexport interface AuthState {\r\n  isSignedIn: boolean;\r\n  user?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Data model type\r\n */\r\nexport type DataModel = Record<string, unknown>;\r\n\r\n/**\r\n * Component schema definition using Zod\r\n */\r\nexport type ComponentSchema = z.ZodType<Record<string, unknown>>;\r\n\r\n/**\r\n * Validation mode for catalog validation\r\n */\r\nexport type ValidationMode = \"strict\" | \"warn\" | \"ignore\";\r\n\r\n/**\r\n * JSON patch operation types\r\n */\r\nexport type PatchOp = \"add\" | \"remove\" | \"replace\" | \"set\";\r\n\r\n/**\r\n * JSON patch operation\r\n */\r\nexport interface JsonPatch {\r\n  op: PatchOp;\r\n  path: string;\r\n  value?: unknown;\r\n}\r\n\r\n/**\r\n * Resolve a dynamic value against a data model\r\n */\r\nexport function resolveDynamicValue<T>(\r\n  value: DynamicValue<T>,\r\n  dataModel: DataModel,\r\n): T | undefined {\r\n  if (value === null || value === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  if (typeof value === \"object\" && \"path\" in value) {\r\n    return getByPath(dataModel, value.path) as T | undefined;\r\n  }\r\n\r\n  return value as T;\r\n}\r\n\r\n/**\r\n * Get a value from an object by JSON Pointer path\r\n */\r\nexport function getByPath(obj: unknown, path: string): unknown {\r\n  if (!path || path === \"/\") {\r\n    return obj;\r\n  }\r\n\r\n  const segments = path.startsWith(\"/\")\r\n    ? path.slice(1).split(\"/\")\r\n    : path.split(\"/\");\r\n\r\n  let current: unknown = obj;\r\n\r\n  for (const segment of segments) {\r\n    if (current === null || current === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    if (typeof current === \"object\") {\r\n      current = (current as Record<string, unknown>)[segment];\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  return current;\r\n}\r\n\r\n/**\r\n * Set a value in an object by JSON Pointer path\r\n */\r\nexport function setByPath(\r\n  obj: Record<string, unknown>,\r\n  path: string,\r\n  value: unknown,\r\n): void {\r\n  const segments = path.startsWith(\"/\")\r\n    ? path.slice(1).split(\"/\")\r\n    : path.split(\"/\");\r\n\r\n  if (segments.length === 0) return;\r\n\r\n  let current: Record<string, unknown> = obj;\r\n\r\n  for (let i = 0; i < segments.length - 1; i++) {\r\n    const segment = segments[i]!;\r\n    if (!(segment in current) || typeof current[segment] !== \"object\") {\r\n      current[segment] = {};\r\n    }\r\n    current = current[segment] as Record<string, unknown>;\r\n  }\r\n\r\n  const lastSegment = segments[segments.length - 1]!;\r\n  current[lastSegment] = value;\r\n}\r\n","import { z } from \"zod\";\r\nimport type {\r\n  VisibilityCondition,\r\n  LogicExpression,\r\n  DataModel,\r\n  AuthState,\r\n  DynamicValue,\r\n} from \"./types\";\r\nimport { resolveDynamicValue, DynamicValueSchema } from \"./types\";\r\n\r\n// Dynamic value schema for comparisons (number-focused)\r\nconst DynamicNumberValueSchema = z.union([\r\n  z.number(),\r\n  z.object({ path: z.string() }),\r\n]);\r\n\r\n/**\r\n * Logic expression schema (recursive)\r\n * Using a more permissive schema that aligns with runtime behavior\r\n */\r\nexport const LogicExpressionSchema: z.ZodType<LogicExpression> = z.lazy(() =>\r\n  z.union([\r\n    z.object({ and: z.array(LogicExpressionSchema) }),\r\n    z.object({ or: z.array(LogicExpressionSchema) }),\r\n    z.object({ not: LogicExpressionSchema }),\r\n    z.object({ path: z.string() }),\r\n    z.object({ eq: z.tuple([DynamicValueSchema, DynamicValueSchema]) }),\r\n    z.object({ neq: z.tuple([DynamicValueSchema, DynamicValueSchema]) }),\r\n    z.object({\r\n      gt: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\r\n    }),\r\n    z.object({\r\n      gte: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\r\n    }),\r\n    z.object({\r\n      lt: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\r\n    }),\r\n    z.object({\r\n      lte: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\r\n    }),\r\n  ]),\r\n) as z.ZodType<LogicExpression>;\r\n\r\n/**\r\n * Visibility condition schema\r\n */\r\nexport const VisibilityConditionSchema: z.ZodType<VisibilityCondition> =\r\n  z.union([\r\n    z.boolean(),\r\n    z.object({ path: z.string() }),\r\n    z.object({ auth: z.enum([\"signedIn\", \"signedOut\"]) }),\r\n    LogicExpressionSchema,\r\n  ]);\r\n\r\n/**\r\n * Context for evaluating visibility\r\n */\r\nexport interface VisibilityContext {\r\n  dataModel: DataModel;\r\n  authState?: AuthState;\r\n}\r\n\r\n/**\r\n * Evaluate a logic expression against data and auth state\r\n */\r\nexport function evaluateLogicExpression(\r\n  expr: LogicExpression,\r\n  ctx: VisibilityContext,\r\n): boolean {\r\n  const { dataModel } = ctx;\r\n\r\n  // AND expression\r\n  if (\"and\" in expr) {\r\n    return expr.and.every((subExpr) => evaluateLogicExpression(subExpr, ctx));\r\n  }\r\n\r\n  // OR expression\r\n  if (\"or\" in expr) {\r\n    return expr.or.some((subExpr) => evaluateLogicExpression(subExpr, ctx));\r\n  }\r\n\r\n  // NOT expression\r\n  if (\"not\" in expr) {\r\n    return !evaluateLogicExpression(expr.not, ctx);\r\n  }\r\n\r\n  // Path expression (resolve to boolean)\r\n  if (\"path\" in expr) {\r\n    const value = resolveDynamicValue({ path: expr.path }, dataModel);\r\n    return Boolean(value);\r\n  }\r\n\r\n  // Equality comparison\r\n  if (\"eq\" in expr) {\r\n    const [left, right] = expr.eq;\r\n    const leftValue = resolveDynamicValue(left, dataModel);\r\n    const rightValue = resolveDynamicValue(right, dataModel);\r\n    return leftValue === rightValue;\r\n  }\r\n\r\n  // Not equal comparison\r\n  if (\"neq\" in expr) {\r\n    const [left, right] = expr.neq;\r\n    const leftValue = resolveDynamicValue(left, dataModel);\r\n    const rightValue = resolveDynamicValue(right, dataModel);\r\n    return leftValue !== rightValue;\r\n  }\r\n\r\n  // Greater than\r\n  if (\"gt\" in expr) {\r\n    const [left, right] = expr.gt;\r\n    const leftValue = resolveDynamicValue(\r\n      left as DynamicValue<number>,\r\n      dataModel,\r\n    );\r\n    const rightValue = resolveDynamicValue(\r\n      right as DynamicValue<number>,\r\n      dataModel,\r\n    );\r\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\r\n      return leftValue > rightValue;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Greater than or equal\r\n  if (\"gte\" in expr) {\r\n    const [left, right] = expr.gte;\r\n    const leftValue = resolveDynamicValue(\r\n      left as DynamicValue<number>,\r\n      dataModel,\r\n    );\r\n    const rightValue = resolveDynamicValue(\r\n      right as DynamicValue<number>,\r\n      dataModel,\r\n    );\r\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\r\n      return leftValue >= rightValue;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Less than\r\n  if (\"lt\" in expr) {\r\n    const [left, right] = expr.lt;\r\n    const leftValue = resolveDynamicValue(\r\n      left as DynamicValue<number>,\r\n      dataModel,\r\n    );\r\n    const rightValue = resolveDynamicValue(\r\n      right as DynamicValue<number>,\r\n      dataModel,\r\n    );\r\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\r\n      return leftValue < rightValue;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Less than or equal\r\n  if (\"lte\" in expr) {\r\n    const [left, right] = expr.lte;\r\n    const leftValue = resolveDynamicValue(\r\n      left as DynamicValue<number>,\r\n      dataModel,\r\n    );\r\n    const rightValue = resolveDynamicValue(\r\n      right as DynamicValue<number>,\r\n      dataModel,\r\n    );\r\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\r\n      return leftValue <= rightValue;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Evaluate a visibility condition\r\n */\r\nexport function evaluateVisibility(\r\n  condition: VisibilityCondition | undefined,\r\n  ctx: VisibilityContext,\r\n): boolean {\r\n  // No condition = visible\r\n  if (condition === undefined) {\r\n    return true;\r\n  }\r\n\r\n  // Boolean literal\r\n  if (typeof condition === \"boolean\") {\r\n    return condition;\r\n  }\r\n\r\n  // Path reference\r\n  if (\"path\" in condition && !(\"and\" in condition) && !(\"or\" in condition)) {\r\n    const value = resolveDynamicValue({ path: condition.path }, ctx.dataModel);\r\n    return Boolean(value);\r\n  }\r\n\r\n  // Auth condition\r\n  if (\"auth\" in condition) {\r\n    const isSignedIn = ctx.authState?.isSignedIn ?? false;\r\n    if (condition.auth === \"signedIn\") {\r\n      return isSignedIn;\r\n    }\r\n    if (condition.auth === \"signedOut\") {\r\n      return !isSignedIn;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Logic expression\r\n  return evaluateLogicExpression(condition as LogicExpression, ctx);\r\n}\r\n\r\n/**\r\n * Helper to create visibility conditions\r\n */\r\nexport const visibility = {\r\n  /** Always visible */\r\n  always: true as const,\r\n\r\n  /** Never visible */\r\n  never: false as const,\r\n\r\n  /** Visible when path is truthy */\r\n  when: (path: string): VisibilityCondition => ({ path }),\r\n\r\n  /** Visible when signed in */\r\n  signedIn: { auth: \"signedIn\" } as const,\r\n\r\n  /** Visible when signed out */\r\n  signedOut: { auth: \"signedOut\" } as const,\r\n\r\n  /** AND multiple conditions */\r\n  and: (...conditions: LogicExpression[]): LogicExpression => ({\r\n    and: conditions,\r\n  }),\r\n\r\n  /** OR multiple conditions */\r\n  or: (...conditions: LogicExpression[]): LogicExpression => ({\r\n    or: conditions,\r\n  }),\r\n\r\n  /** NOT a condition */\r\n  not: (condition: LogicExpression): LogicExpression => ({ not: condition }),\r\n\r\n  /** Equality check */\r\n  eq: (left: DynamicValue, right: DynamicValue): LogicExpression => ({\r\n    eq: [left, right],\r\n  }),\r\n\r\n  /** Not equal check */\r\n  neq: (left: DynamicValue, right: DynamicValue): LogicExpression => ({\r\n    neq: [left, right],\r\n  }),\r\n\r\n  /** Greater than */\r\n  gt: (\r\n    left: DynamicValue<number>,\r\n    right: DynamicValue<number>,\r\n  ): LogicExpression => ({ gt: [left, right] }),\r\n\r\n  /** Greater than or equal */\r\n  gte: (\r\n    left: DynamicValue<number>,\r\n    right: DynamicValue<number>,\r\n  ): LogicExpression => ({ gte: [left, right] }),\r\n\r\n  /** Less than */\r\n  lt: (\r\n    left: DynamicValue<number>,\r\n    right: DynamicValue<number>,\r\n  ): LogicExpression => ({ lt: [left, right] }),\r\n\r\n  /** Less than or equal */\r\n  lte: (\r\n    left: DynamicValue<number>,\r\n    right: DynamicValue<number>,\r\n  ): LogicExpression => ({ lte: [left, right] }),\r\n};\r\n","import { z } from \"zod\";\r\nimport type { DynamicValue, DataModel } from \"./types\";\r\nimport { DynamicValueSchema, resolveDynamicValue } from \"./types\";\r\n\r\n/**\r\n * Confirmation dialog configuration\r\n */\r\nexport interface ActionConfirm {\r\n  title: string;\r\n  message: string;\r\n  confirmLabel?: string;\r\n  cancelLabel?: string;\r\n  variant?: \"default\" | \"danger\";\r\n}\r\n\r\n/**\r\n * Action success handler\r\n */\r\nexport type ActionOnSuccess =\r\n  | { navigate: string }\r\n  | { set: Record<string, unknown> }\r\n  | { action: string };\r\n\r\n/**\r\n * Action error handler\r\n */\r\nexport type ActionOnError =\r\n  | { set: Record<string, unknown> }\r\n  | { action: string };\r\n\r\n/**\r\n * Rich action definition\r\n */\r\nexport interface Action {\r\n  /** Action name (must be in catalog) */\r\n  name: string;\r\n  /** Parameters to pass to the action handler */\r\n  params?: Record<string, DynamicValue>;\r\n  /** Confirmation dialog before execution */\r\n  confirm?: ActionConfirm;\r\n  /** Handler after successful execution */\r\n  onSuccess?: ActionOnSuccess;\r\n  /** Handler after failed execution */\r\n  onError?: ActionOnError;\r\n}\r\n\r\n/**\r\n * Schema for action confirmation\r\n */\r\nexport const ActionConfirmSchema = z.object({\r\n  title: z.string(),\r\n  message: z.string(),\r\n  confirmLabel: z.string().optional(),\r\n  cancelLabel: z.string().optional(),\r\n  variant: z.enum([\"default\", \"danger\"]).optional(),\r\n});\r\n\r\n/**\r\n * Schema for success handlers\r\n */\r\nexport const ActionOnSuccessSchema = z.union([\r\n  z.object({ navigate: z.string() }),\r\n  z.object({ set: z.record(z.string(), z.unknown()) }),\r\n  z.object({ action: z.string() }),\r\n]);\r\n\r\n/**\r\n * Schema for error handlers\r\n */\r\nexport const ActionOnErrorSchema = z.union([\r\n  z.object({ set: z.record(z.string(), z.unknown()) }),\r\n  z.object({ action: z.string() }),\r\n]);\r\n\r\n/**\r\n * Full action schema\r\n */\r\nexport const ActionSchema = z.object({\r\n  name: z.string(),\r\n  params: z.record(z.string(), DynamicValueSchema).optional(),\r\n  confirm: ActionConfirmSchema.optional(),\r\n  onSuccess: ActionOnSuccessSchema.optional(),\r\n  onError: ActionOnErrorSchema.optional(),\r\n});\r\n\r\n/**\r\n * Action handler function signature\r\n */\r\nexport type ActionHandler<\r\n  TParams = Record<string, unknown>,\r\n  TResult = unknown,\r\n> = (params: TParams) => Promise<TResult> | TResult;\r\n\r\n/**\r\n * Action definition in catalog\r\n */\r\nexport interface ActionDefinition<TParams = Record<string, unknown>> {\r\n  /** Zod schema for params validation */\r\n  params?: z.ZodType<TParams>;\r\n  /** Description for AI */\r\n  description?: string;\r\n}\r\n\r\n/**\r\n * Resolved action with all dynamic values resolved\r\n */\r\nexport interface ResolvedAction {\r\n  name: string;\r\n  params: Record<string, unknown>;\r\n  confirm?: ActionConfirm;\r\n  onSuccess?: ActionOnSuccess;\r\n  onError?: ActionOnError;\r\n}\r\n\r\n/**\r\n * Resolve all dynamic values in an action\r\n */\r\nexport function resolveAction(\r\n  action: Action,\r\n  dataModel: DataModel,\r\n): ResolvedAction {\r\n  const resolvedParams: Record<string, unknown> = {};\r\n\r\n  if (action.params) {\r\n    for (const [key, value] of Object.entries(action.params)) {\r\n      resolvedParams[key] = resolveDynamicValue(value, dataModel);\r\n    }\r\n  }\r\n\r\n  // Interpolate confirmation message if present\r\n  let confirm = action.confirm;\r\n  if (confirm) {\r\n    confirm = {\r\n      ...confirm,\r\n      message: interpolateString(confirm.message, dataModel),\r\n      title: interpolateString(confirm.title, dataModel),\r\n    };\r\n  }\r\n\r\n  return {\r\n    name: action.name,\r\n    params: resolvedParams,\r\n    confirm,\r\n    onSuccess: action.onSuccess,\r\n    onError: action.onError,\r\n  };\r\n}\r\n\r\n/**\r\n * Interpolate ${path} expressions in a string\r\n */\r\nexport function interpolateString(\r\n  template: string,\r\n  dataModel: DataModel,\r\n): string {\r\n  return template.replace(/\\$\\{([^}]+)\\}/g, (_, path) => {\r\n    const value = resolveDynamicValue({ path }, dataModel);\r\n    return String(value ?? \"\");\r\n  });\r\n}\r\n\r\n/**\r\n * Context for action execution\r\n */\r\nexport interface ActionExecutionContext {\r\n  /** The resolved action */\r\n  action: ResolvedAction;\r\n  /** The action handler from the host */\r\n  handler: ActionHandler;\r\n  /** Function to update data model */\r\n  setData: (path: string, value: unknown) => void;\r\n  /** Function to navigate */\r\n  navigate?: (path: string) => void;\r\n  /** Function to execute another action */\r\n  executeAction?: (name: string) => Promise<void>;\r\n}\r\n\r\n/**\r\n * Execute an action with all callbacks\r\n */\r\nexport async function executeAction(\r\n  ctx: ActionExecutionContext,\r\n): Promise<void> {\r\n  const { action, handler, setData, navigate, executeAction } = ctx;\r\n\r\n  try {\r\n    await handler(action.params);\r\n\r\n    // Handle success\r\n    if (action.onSuccess) {\r\n      if (\"navigate\" in action.onSuccess && navigate) {\r\n        navigate(action.onSuccess.navigate);\r\n      } else if (\"set\" in action.onSuccess) {\r\n        for (const [path, value] of Object.entries(action.onSuccess.set)) {\r\n          setData(path, value);\r\n        }\r\n      } else if (\"action\" in action.onSuccess && executeAction) {\r\n        await executeAction(action.onSuccess.action);\r\n      }\r\n    }\r\n  } catch (error) {\r\n    // Handle error\r\n    if (action.onError) {\r\n      if (\"set\" in action.onError) {\r\n        for (const [path, value] of Object.entries(action.onError.set)) {\r\n          // Replace $error.message with actual error\r\n          const resolvedValue =\r\n            typeof value === \"string\" && value === \"$error.message\"\r\n              ? (error as Error).message\r\n              : value;\r\n          setData(path, resolvedValue);\r\n        }\r\n      } else if (\"action\" in action.onError && executeAction) {\r\n        await executeAction(action.onError.action);\r\n      }\r\n    } else {\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Helper to create actions\r\n */\r\nexport const action = {\r\n  /** Create a simple action */\r\n  simple: (name: string, params?: Record<string, DynamicValue>): Action => ({\r\n    name,\r\n    params,\r\n  }),\r\n\r\n  /** Create an action with confirmation */\r\n  withConfirm: (\r\n    name: string,\r\n    confirm: ActionConfirm,\r\n    params?: Record<string, DynamicValue>,\r\n  ): Action => ({\r\n    name,\r\n    params,\r\n    confirm,\r\n  }),\r\n\r\n  /** Create an action with success handler */\r\n  withSuccess: (\r\n    name: string,\r\n    onSuccess: ActionOnSuccess,\r\n    params?: Record<string, DynamicValue>,\r\n  ): Action => ({\r\n    name,\r\n    params,\r\n    onSuccess,\r\n  }),\r\n};\r\n","import { z } from \"zod\";\r\nimport type { DynamicValue, DataModel, LogicExpression } from \"./types\";\r\nimport { DynamicValueSchema, resolveDynamicValue } from \"./types\";\r\nimport { LogicExpressionSchema, evaluateLogicExpression } from \"./visibility\";\r\n\r\n/**\r\n * Validation check definition\r\n */\r\nexport interface ValidationCheck {\r\n  /** Function name (built-in or from catalog) */\r\n  fn: string;\r\n  /** Additional arguments for the function */\r\n  args?: Record<string, DynamicValue>;\r\n  /** Error message to display if check fails */\r\n  message: string;\r\n}\r\n\r\n/**\r\n * Validation configuration for a field\r\n */\r\nexport interface ValidationConfig {\r\n  /** Array of checks to run */\r\n  checks?: ValidationCheck[];\r\n  /** When to run validation */\r\n  validateOn?: \"change\" | \"blur\" | \"submit\";\r\n  /** Condition for when validation is enabled */\r\n  enabled?: LogicExpression;\r\n}\r\n\r\n/**\r\n * Schema for validation check\r\n */\r\nexport const ValidationCheckSchema = z.object({\r\n  fn: z.string(),\r\n  args: z.record(z.string(), DynamicValueSchema).optional(),\r\n  message: z.string(),\r\n});\r\n\r\n/**\r\n * Schema for validation config\r\n */\r\nexport const ValidationConfigSchema = z.object({\r\n  checks: z.array(ValidationCheckSchema).optional(),\r\n  validateOn: z.enum([\"change\", \"blur\", \"submit\"]).optional(),\r\n  enabled: LogicExpressionSchema.optional(),\r\n});\r\n\r\n/**\r\n * Validation function signature\r\n */\r\nexport type ValidationFunction = (\r\n  value: unknown,\r\n  args?: Record<string, unknown>,\r\n) => boolean;\r\n\r\n/**\r\n * Validation function definition in catalog\r\n */\r\nexport interface ValidationFunctionDefinition {\r\n  /** The validation function */\r\n  validate: ValidationFunction;\r\n  /** Description for AI */\r\n  description?: string;\r\n}\r\n\r\n/**\r\n * Built-in validation functions\r\n */\r\nexport const builtInValidationFunctions: Record<string, ValidationFunction> = {\r\n  /**\r\n   * Check if value is not null, undefined, or empty string\r\n   */\r\n  required: (value: unknown) => {\r\n    if (value === null || value === undefined) return false;\r\n    if (typeof value === \"string\") return value.trim().length > 0;\r\n    if (Array.isArray(value)) return value.length > 0;\r\n    return true;\r\n  },\r\n\r\n  /**\r\n   * Check if value is a valid email address\r\n   */\r\n  email: (value: unknown) => {\r\n    if (typeof value !== \"string\") return false;\r\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value);\r\n  },\r\n\r\n  /**\r\n   * Check minimum string length\r\n   */\r\n  minLength: (value: unknown, args?: Record<string, unknown>) => {\r\n    if (typeof value !== \"string\") return false;\r\n    const min = args?.min;\r\n    if (typeof min !== \"number\") return false;\r\n    return value.length >= min;\r\n  },\r\n\r\n  /**\r\n   * Check maximum string length\r\n   */\r\n  maxLength: (value: unknown, args?: Record<string, unknown>) => {\r\n    if (typeof value !== \"string\") return false;\r\n    const max = args?.max;\r\n    if (typeof max !== \"number\") return false;\r\n    return value.length <= max;\r\n  },\r\n\r\n  /**\r\n   * Check if string matches a regex pattern\r\n   */\r\n  pattern: (value: unknown, args?: Record<string, unknown>) => {\r\n    if (typeof value !== \"string\") return false;\r\n    const pattern = args?.pattern;\r\n    if (typeof pattern !== \"string\") return false;\r\n    try {\r\n      return new RegExp(pattern).test(value);\r\n    } catch {\r\n      return false;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check minimum numeric value\r\n   */\r\n  min: (value: unknown, args?: Record<string, unknown>) => {\r\n    if (typeof value !== \"number\") return false;\r\n    const min = args?.min;\r\n    if (typeof min !== \"number\") return false;\r\n    return value >= min;\r\n  },\r\n\r\n  /**\r\n   * Check maximum numeric value\r\n   */\r\n  max: (value: unknown, args?: Record<string, unknown>) => {\r\n    if (typeof value !== \"number\") return false;\r\n    const max = args?.max;\r\n    if (typeof max !== \"number\") return false;\r\n    return value <= max;\r\n  },\r\n\r\n  /**\r\n   * Check if value is a number\r\n   */\r\n  numeric: (value: unknown) => {\r\n    if (typeof value === \"number\") return !isNaN(value);\r\n    if (typeof value === \"string\") return !isNaN(parseFloat(value));\r\n    return false;\r\n  },\r\n\r\n  /**\r\n   * Check if value is a valid URL\r\n   */\r\n  url: (value: unknown) => {\r\n    if (typeof value !== \"string\") return false;\r\n    try {\r\n      new URL(value);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check if value matches another field\r\n   */\r\n  matches: (value: unknown, args?: Record<string, unknown>) => {\r\n    const other = args?.other;\r\n    return value === other;\r\n  },\r\n};\r\n\r\n/**\r\n * Validation result for a single check\r\n */\r\nexport interface ValidationCheckResult {\r\n  fn: string;\r\n  valid: boolean;\r\n  message: string;\r\n}\r\n\r\n/**\r\n * Full validation result for a field\r\n */\r\nexport interface ValidationResult {\r\n  valid: boolean;\r\n  errors: string[];\r\n  checks: ValidationCheckResult[];\r\n}\r\n\r\n/**\r\n * Context for running validation\r\n */\r\nexport interface ValidationContext {\r\n  /** Current value to validate */\r\n  value: unknown;\r\n  /** Full data model for resolving paths */\r\n  dataModel: DataModel;\r\n  /** Custom validation functions from catalog */\r\n  customFunctions?: Record<string, ValidationFunction>;\r\n}\r\n\r\n/**\r\n * Run a single validation check\r\n */\r\nexport function runValidationCheck(\r\n  check: ValidationCheck,\r\n  ctx: ValidationContext,\r\n): ValidationCheckResult {\r\n  const { value, dataModel, customFunctions } = ctx;\r\n\r\n  // Resolve args\r\n  const resolvedArgs: Record<string, unknown> = {};\r\n  if (check.args) {\r\n    for (const [key, argValue] of Object.entries(check.args)) {\r\n      resolvedArgs[key] = resolveDynamicValue(argValue, dataModel);\r\n    }\r\n  }\r\n\r\n  // Find the validation function\r\n  const fn =\r\n    builtInValidationFunctions[check.fn] ?? customFunctions?.[check.fn];\r\n\r\n  if (!fn) {\r\n    console.warn(`Unknown validation function: ${check.fn}`);\r\n    return {\r\n      fn: check.fn,\r\n      valid: true, // Don't fail on unknown functions\r\n      message: check.message,\r\n    };\r\n  }\r\n\r\n  const valid = fn(value, resolvedArgs);\r\n\r\n  return {\r\n    fn: check.fn,\r\n    valid,\r\n    message: check.message,\r\n  };\r\n}\r\n\r\n/**\r\n * Run all validation checks for a field\r\n */\r\nexport function runValidation(\r\n  config: ValidationConfig,\r\n  ctx: ValidationContext & { authState?: { isSignedIn: boolean } },\r\n): ValidationResult {\r\n  const checks: ValidationCheckResult[] = [];\r\n  const errors: string[] = [];\r\n\r\n  // Check if validation is enabled\r\n  if (config.enabled) {\r\n    const enabled = evaluateLogicExpression(config.enabled, {\r\n      dataModel: ctx.dataModel,\r\n      authState: ctx.authState,\r\n    });\r\n    if (!enabled) {\r\n      return { valid: true, errors: [], checks: [] };\r\n    }\r\n  }\r\n\r\n  // Run each check\r\n  if (config.checks) {\r\n    for (const check of config.checks) {\r\n      const result = runValidationCheck(check, ctx);\r\n      checks.push(result);\r\n      if (!result.valid) {\r\n        errors.push(result.message);\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    checks,\r\n  };\r\n}\r\n\r\n/**\r\n * Helper to create validation checks\r\n */\r\nexport const check = {\r\n  required: (message = \"This field is required\"): ValidationCheck => ({\r\n    fn: \"required\",\r\n    message,\r\n  }),\r\n\r\n  email: (message = \"Invalid email address\"): ValidationCheck => ({\r\n    fn: \"email\",\r\n    message,\r\n  }),\r\n\r\n  minLength: (min: number, message?: string): ValidationCheck => ({\r\n    fn: \"minLength\",\r\n    args: { min },\r\n    message: message ?? `Must be at least ${min} characters`,\r\n  }),\r\n\r\n  maxLength: (max: number, message?: string): ValidationCheck => ({\r\n    fn: \"maxLength\",\r\n    args: { max },\r\n    message: message ?? `Must be at most ${max} characters`,\r\n  }),\r\n\r\n  pattern: (pattern: string, message = \"Invalid format\"): ValidationCheck => ({\r\n    fn: \"pattern\",\r\n    args: { pattern },\r\n    message,\r\n  }),\r\n\r\n  min: (min: number, message?: string): ValidationCheck => ({\r\n    fn: \"min\",\r\n    args: { min },\r\n    message: message ?? `Must be at least ${min}`,\r\n  }),\r\n\r\n  max: (max: number, message?: string): ValidationCheck => ({\r\n    fn: \"max\",\r\n    args: { max },\r\n    message: message ?? `Must be at most ${max}`,\r\n  }),\r\n\r\n  url: (message = \"Invalid URL\"): ValidationCheck => ({\r\n    fn: \"url\",\r\n    message,\r\n  }),\r\n\r\n  matches: (\r\n    otherPath: string,\r\n    message = \"Fields must match\",\r\n  ): ValidationCheck => ({\r\n    fn: \"matches\",\r\n    args: { other: { path: otherPath } },\r\n    message,\r\n  }),\r\n};\r\n","import { z } from \"zod\";\r\nimport type {\r\n  ComponentSchema,\r\n  ValidationMode,\r\n  UIElement,\r\n  UITree,\r\n  VisibilityCondition,\r\n} from \"./types\";\r\nimport { VisibilityConditionSchema } from \"./visibility\";\r\nimport { ActionSchema, type ActionDefinition } from \"./actions\";\r\nimport { ValidationConfigSchema, type ValidationFunction } from \"./validation\";\r\n\r\n/**\r\n * Component definition with visibility and validation support\r\n */\r\nexport interface ComponentDefinition<\r\n  TProps extends ComponentSchema = ComponentSchema,\r\n> {\r\n  /** Zod schema for component props */\r\n  props: TProps;\r\n  /** Whether this component can have children */\r\n  hasChildren?: boolean;\r\n  /** Description for AI generation */\r\n  description?: string;\r\n}\r\n\r\n/**\r\n * Catalog configuration\r\n */\r\nexport interface CatalogConfig<\r\n  TComponents extends Record<string, ComponentDefinition> = Record<\r\n    string,\r\n    ComponentDefinition\r\n  >,\r\n  TActions extends Record<string, ActionDefinition> = Record<\r\n    string,\r\n    ActionDefinition\r\n  >,\r\n  TFunctions extends Record<string, ValidationFunction> = Record<\r\n    string,\r\n    ValidationFunction\r\n  >,\r\n> {\r\n  /** Catalog name */\r\n  name?: string;\r\n  /** Component definitions */\r\n  components: TComponents;\r\n  /** Action definitions with param schemas */\r\n  actions?: TActions;\r\n  /** Custom validation functions */\r\n  functions?: TFunctions;\r\n  /** Validation mode */\r\n  validation?: ValidationMode;\r\n}\r\n\r\n/**\r\n * Catalog instance\r\n */\r\nexport interface Catalog<\r\n  TComponents extends Record<string, ComponentDefinition> = Record<\r\n    string,\r\n    ComponentDefinition\r\n  >,\r\n  TActions extends Record<string, ActionDefinition> = Record<\r\n    string,\r\n    ActionDefinition\r\n  >,\r\n  TFunctions extends Record<string, ValidationFunction> = Record<\r\n    string,\r\n    ValidationFunction\r\n  >,\r\n> {\r\n  /** Catalog name */\r\n  readonly name: string;\r\n  /** Component names */\r\n  readonly componentNames: (keyof TComponents)[];\r\n  /** Action names */\r\n  readonly actionNames: (keyof TActions)[];\r\n  /** Function names */\r\n  readonly functionNames: (keyof TFunctions)[];\r\n  /** Validation mode */\r\n  readonly validation: ValidationMode;\r\n  /** Component definitions */\r\n  readonly components: TComponents;\r\n  /** Action definitions */\r\n  readonly actions: TActions;\r\n  /** Custom validation functions */\r\n  readonly functions: TFunctions;\r\n  /** Full element schema for AI generation */\r\n  readonly elementSchema: z.ZodType<UIElement>;\r\n  /** Full UI tree schema */\r\n  readonly treeSchema: z.ZodType<UITree>;\r\n  /** Check if component exists */\r\n  hasComponent(type: string): boolean;\r\n  /** Check if action exists */\r\n  hasAction(name: string): boolean;\r\n  /** Check if function exists */\r\n  hasFunction(name: string): boolean;\r\n  /** Validate an element */\r\n  validateElement(element: unknown): {\r\n    success: boolean;\r\n    data?: UIElement;\r\n    error?: z.ZodError;\r\n  };\r\n  /** Validate a UI tree */\r\n  validateTree(tree: unknown): {\r\n    success: boolean;\r\n    data?: UITree;\r\n    error?: z.ZodError;\r\n  };\r\n}\r\n\r\n/**\r\n * Create a v2 catalog with visibility, actions, and validation support\r\n */\r\nexport function createCatalog<\r\n  TComponents extends Record<string, ComponentDefinition>,\r\n  TActions extends Record<string, ActionDefinition> = Record<\r\n    string,\r\n    ActionDefinition\r\n  >,\r\n  TFunctions extends Record<string, ValidationFunction> = Record<\r\n    string,\r\n    ValidationFunction\r\n  >,\r\n>(\r\n  config: CatalogConfig<TComponents, TActions, TFunctions>,\r\n): Catalog<TComponents, TActions, TFunctions> {\r\n  const {\r\n    name = \"unnamed\",\r\n    components,\r\n    actions = {} as TActions,\r\n    functions = {} as TFunctions,\r\n    validation = \"strict\",\r\n  } = config;\r\n\r\n  const componentNames = Object.keys(components) as (keyof TComponents)[];\r\n  const actionNames = Object.keys(actions) as (keyof TActions)[];\r\n  const functionNames = Object.keys(functions) as (keyof TFunctions)[];\r\n\r\n  // Create element schema for each component type\r\n  const componentSchemas = componentNames.map((componentName) => {\r\n    const def = components[componentName]!;\r\n\r\n    return z.object({\r\n      key: z.string(),\r\n      type: z.literal(componentName as string),\r\n      props: def.props,\r\n      children: z.array(z.string()).optional(),\r\n      parentKey: z.string().nullable().optional(),\r\n      visible: VisibilityConditionSchema.optional(),\r\n    });\r\n  });\r\n\r\n  // Create union schema for all components\r\n  let elementSchema: z.ZodType<UIElement>;\r\n\r\n  if (componentSchemas.length === 0) {\r\n    elementSchema = z.object({\r\n      key: z.string(),\r\n      type: z.string(),\r\n      props: z.record(z.string(), z.unknown()),\r\n      children: z.array(z.string()).optional(),\r\n      parentKey: z.string().nullable().optional(),\r\n      visible: VisibilityConditionSchema.optional(),\r\n    }) as unknown as z.ZodType<UIElement>;\r\n  } else if (componentSchemas.length === 1) {\r\n    elementSchema = componentSchemas[0] as unknown as z.ZodType<UIElement>;\r\n  } else {\r\n    elementSchema = z.discriminatedUnion(\"type\", [\r\n      componentSchemas[0] as z.ZodObject<any>,\r\n      componentSchemas[1] as z.ZodObject<any>,\r\n      ...(componentSchemas.slice(2) as z.ZodObject<any>[]),\r\n    ]) as unknown as z.ZodType<UIElement>;\r\n  }\r\n\r\n  // Create tree schema\r\n  const treeSchema = z.object({\r\n    root: z.string(),\r\n    elements: z.record(z.string(), elementSchema),\r\n  }) as unknown as z.ZodType<UITree>;\r\n\r\n  return {\r\n    name,\r\n    componentNames,\r\n    actionNames,\r\n    functionNames,\r\n    validation,\r\n    components,\r\n    actions,\r\n    functions,\r\n    elementSchema,\r\n    treeSchema,\r\n\r\n    hasComponent(type: string) {\r\n      return type in components;\r\n    },\r\n\r\n    hasAction(name: string) {\r\n      return name in actions;\r\n    },\r\n\r\n    hasFunction(name: string) {\r\n      return name in functions;\r\n    },\r\n\r\n    validateElement(element: unknown) {\r\n      const result = elementSchema.safeParse(element);\r\n      if (result.success) {\r\n        return { success: true, data: result.data };\r\n      }\r\n      return { success: false, error: result.error };\r\n    },\r\n\r\n    validateTree(tree: unknown) {\r\n      const result = treeSchema.safeParse(tree);\r\n      if (result.success) {\r\n        return { success: true, data: result.data };\r\n      }\r\n      return { success: false, error: result.error };\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Generate a prompt for AI that describes the catalog\r\n */\r\nexport function generateCatalogPrompt<\r\n  TComponents extends Record<string, ComponentDefinition>,\r\n  TActions extends Record<string, ActionDefinition>,\r\n  TFunctions extends Record<string, ValidationFunction>,\r\n>(catalog: Catalog<TComponents, TActions, TFunctions>): string {\r\n  const lines: string[] = [\r\n    `# ${catalog.name} Component Catalog`,\r\n    \"\",\r\n    \"## Available Components\",\r\n    \"\",\r\n  ];\r\n\r\n  // Components\r\n  for (const name of catalog.componentNames) {\r\n    const def = catalog.components[name]!;\r\n    lines.push(`### ${String(name)}`);\r\n    if (def.description) {\r\n      lines.push(def.description);\r\n    }\r\n    lines.push(\"\");\r\n  }\r\n\r\n  // Actions\r\n  if (catalog.actionNames.length > 0) {\r\n    lines.push(\"## Available Actions\");\r\n    lines.push(\"\");\r\n    for (const name of catalog.actionNames) {\r\n      const def = catalog.actions[name]!;\r\n      lines.push(\r\n        `- \\`${String(name)}\\`${def.description ? `: ${def.description}` : \"\"}`,\r\n      );\r\n    }\r\n    lines.push(\"\");\r\n  }\r\n\r\n  // Visibility\r\n  lines.push(\"## Visibility Conditions\");\r\n  lines.push(\"\");\r\n  lines.push(\"Components can have a `visible` property:\");\r\n  lines.push(\"- `true` / `false` - Always visible/hidden\");\r\n  lines.push('- `{ \"path\": \"/data/path\" }` - Visible when path is truthy');\r\n  lines.push('- `{ \"auth\": \"signedIn\" }` - Visible when user is signed in');\r\n  lines.push('- `{ \"and\": [...] }` - All conditions must be true');\r\n  lines.push('- `{ \"or\": [...] }` - Any condition must be true');\r\n  lines.push('- `{ \"not\": {...} }` - Negates a condition');\r\n  lines.push('- `{ \"eq\": [a, b] }` - Equality check');\r\n  lines.push(\"\");\r\n\r\n  // Validation\r\n  lines.push(\"## Validation Functions\");\r\n  lines.push(\"\");\r\n  lines.push(\r\n    \"Built-in: `required`, `email`, `minLength`, `maxLength`, `pattern`, `min`, `max`, `url`\",\r\n  );\r\n  if (catalog.functionNames.length > 0) {\r\n    lines.push(`Custom: ${catalog.functionNames.map(String).join(\", \")}`);\r\n  }\r\n  lines.push(\"\");\r\n\r\n  return lines.join(\"\\n\");\r\n}\r\n\r\n/**\r\n * Type helper to infer component props from catalog\r\n */\r\nexport type InferCatalogComponentProps<\r\n  C extends Catalog<Record<string, ComponentDefinition>>,\r\n> = {\r\n  [K in keyof C[\"components\"]]: z.infer<C[\"components\"][K][\"props\"]>;\r\n};\r\n"],"mappings":"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","names":["z","z","z","z","action","executeAction","z","z","check","z","z","name"]}